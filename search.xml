<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>整数反转</title>
      <link href="/2023/05/30/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2023/05/30/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230530195136.png"><br>在本题中需要注意前提条件为不能存放64位的整数，所以这里如下代码使用long类型就不行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reverse</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="type">long</span> n=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>)&#123;</span><br><span class="line">            n=n*<span class="number">10</span>+x%<span class="number">10</span>;</span><br><span class="line">            x=x/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n&gt;INT_MAX||n&lt;INT_MIN?<span class="number">0</span>:n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面代码利用long类型存放，具体存放大小如图：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230531164340.png"><br>在上述代码中，判断是否溢出直接使用的是INT_MAX以及INT_MIN，在实际反转过程中，实际就是分别得到从个位到最高位的数值，然后进行*10保存的操作。</p><p>同时需要注意一点，在整体循环的条件不应该是x&gt;0,因为已经有负数的存在，所以循环条件为x!&#x3D;0.<br>在实际操作中，需要进行相关处理。这里我们可以推导一下，因为这样我们可以将的到的数&#x2F;10来进行判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(x!=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//每次取末尾数字</span></span><br><span class="line">            <span class="type">int</span> tmp = x%<span class="number">10</span>;</span><br><span class="line">            <span class="comment">//判断是否 大于 最大32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&gt;<span class="number">214748364</span> || (res==<span class="number">214748364</span> &amp;&amp; tmp&gt;<span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断是否 小于 最小32位整数</span></span><br><span class="line">            <span class="keyword">if</span> (res&lt;<span class="number">-214748364</span> || (res==<span class="number">-214748364</span> &amp;&amp; tmp&lt;<span class="number">-8</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res*<span class="number">10</span> + tmp;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br></pre></td></tr></table></figure><p>这里我们可以知道INT_MAX&#x3D;2147483647，我们通过分析在&#x2F;10后得到的余数和得到的商，如果商大于214748364，return 0,如果等于，则判断余数是否大于7，如果是，return 0。对于负数，同样是这种判断，最后可以得到结果。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数学计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>N字形变换</title>
      <link href="/2023/05/30/N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"/>
      <url>/2023/05/30/N%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230530143514.png"><br>这里我想到的第一个方法就是用数组进行模拟，这里后来借鉴了一下别人的思路，利用string的vector二维数组进行模拟，在实际变换中，难点主要是字符串的顺序如何确定，因为在实际遍历时由于N型串方向上的变换，导致遍历时的数组序号不好确定，所以在实际代码中，可以采取标志位的方式进行处理。</p><p>我们可以这样想，当N型串需要转向时主要是到达N型的顶点，在代码中的具体表现即是string数组的序号为0或numRows-1，这样，我们通过顺序遍历字符串，到达顶点时改变flag，使得数组序号变化相反，同时依次将遍历到的字符存入各个数组中，这样就可以实现对其的模拟过程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convert</span><span class="params">(string s, <span class="type">int</span> numRows)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(numRows==<span class="number">1</span>)<span class="keyword">return</span> s;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">rows</span><span class="params">(numRows)</span></span>;</span><br><span class="line">        <span class="type">int</span> flag=<span class="number">1</span>,idrows=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            rows[idrows].<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            idrows += flag;</span><br><span class="line">            <span class="keyword">if</span>(idrows==numRows<span class="number">-1</span>||idrows==<span class="number">0</span>)flag=-flag;</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> row:rows)</span><br><span class="line">        &#123;</span><br><span class="line">            res += row;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的一点是在代码中我们是先存字符再判断，这样对numRows&#x3D;1的情况不适用，所以需要对其特殊处理。<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230530144839.png"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 模拟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文子串</title>
      <link href="/2023/05/29/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/05/29/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230529173603.png"><br>对于这个题目应该很经典了，在这个题目中，我第一个想到的方法是中心扩散，因为回文串的特征便是中心向两边的遍历结果相同，但这里最为经典的做法是动态规划，什么是动态规划，可参考博客<a href="https://www.zhihu.com/question/23995189">https://www.zhihu.com/question/23995189</a>,这里不加详述。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=s.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(n&lt;<span class="number">2</span>)<span class="keyword">return</span> s;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line">        <span class="type">int</span> begin=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> maxlen=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)dp[i][i]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> L=<span class="number">2</span>;L&lt;=n;L++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> j = i+L<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=n)<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[i]!=s[j])dp[i][j]=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j-i&lt;<span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j]=<span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j]=dp[i+<span class="number">1</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(dp[i][j]&amp;&amp;j-i+<span class="number">1</span>&gt;maxlen)&#123;</span><br><span class="line">                    begin=i;</span><br><span class="line">                    maxlen=j-i+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(begin,maxlen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>动态规划的关键是设计状态，以及状态转移方程，在设计状态时注意特殊情况，在上述代码中，表示状态的数据结构为一个二维数组dp，dp[i][j]表示字符串s从位置i到位置j的字串是否为回文串，如果是，则设置为true，如果不是，则设为false。</p><p>在实际结构中，小问题是指小长度字符串是否为回文串，所以在代码中，大循环是字符串长度L，小循环则是起始位置i。</p><p>这里我们需要注意一下初始状态，易知在L&lt;2的情况下，字符串都是回文串，。</p><p>状态转移则是根据起始字符s[i]和终点字符s[j]是否相同决定，我们可以知道如果s[i]!&#x3D;s[j],则对应dp[i][j]需设定为false,反之则应该设为dp[i+1][j-1],这便是小问题求解大问题，但我们还需要加上判断结构，因为如果该字串长度为2，则会出现序号问题，所以当j-i&lt;3时，统一设定为true(就是两个相同的字符,”aa”等)。</p><p>这里在大循环中可能出现错误的还有结束条件，大循环的判断条件好说，就是从L&#x3D;2开始到L&#x3D;n(字符串的长度)，在小循环中，我们设定的循环是起始位置i从0到字符串末尾，然后由于j的序号问题，所以需要设定终点位置j&lt;n,大于则已经到末尾，可以结束循环。</p><p>整体的复杂度还是较高的，时间复杂度由于有两个大循环,则为o(n^2),空间复杂度由于使用了一个二维数组来保存状态所以也为o(n^2)。</p><p>后续有时间再来更新一下其他解法。</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2023/05/29/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2023/05/29/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230529130124.png"><br>这里是一个字符串处理的问题，字符串的字串是连续的，该题目的重点是找没有包含相同字符的字串，为了避免重复，肯定需要哈希表的支持。为了找字串，我们可以这样子来进行思考，首先，我们固定第一个位置为字符串的开始，让第二个位置沿着字符串进行滑动，根据这个位置不断读取字符存入哈希表，在存入之前先进行查重工作，如果发现有重复，从第一个位置开始，不断删除哈希表的字符键值，直到在哈希表中查不到重复字符，整体处于一个字符串的大循环，结束条件是第二个位置到达字符串末尾，然后在这个过程中记录两个位置的最大距离，即为结果。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">1</span>,maxlen=<span class="number">1</span>;</span><br><span class="line">        map.<span class="built_in">insert</span>(s[head]);</span><br><span class="line">        <span class="keyword">for</span>(;tail&lt;len;tail++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(map.<span class="built_in">find</span>(s[tail])!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(s[head]);</span><br><span class="line">                head++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            maxlen=<span class="built_in">max</span>(maxlen,tail-head+<span class="number">1</span>);</span><br><span class="line">            map.<span class="built_in">insert</span>(s[tail]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如上代码可以看做一个“滑动窗口”的模板，这里将0单独处理，也可以不单独处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">char</span>&gt; map;</span><br><span class="line">        <span class="type">int</span> len=s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//if(len==0)return 0;(这里添加一下)</span></span><br><span class="line">        <span class="type">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>,maxlen=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//map.insert(s[head]);</span></span><br><span class="line">        <span class="keyword">for</span>(;tail&lt;len;tail++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(map.<span class="built_in">find</span>(s[tail])!=map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                map.<span class="built_in">erase</span>(s[head]);</span><br><span class="line">                head++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            maxlen=<span class="built_in">max</span>(maxlen,tail-head+<span class="number">1</span>);</span><br><span class="line">            map.<span class="built_in">insert</span>(s[tail]);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>经过实测，将字符串为空的情况单独处理运行时间似乎可以缩短一些。<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230529131859.png"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 滑动窗口 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数相加</title>
      <link href="/2023/05/28/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2023/05/28/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528163045.png"><br>本题的主要思路是关于十进制数的相加，，这里由于链表将十进制数逆序存放，所以一次遍历链表，从个位开始计算，符号和数学上的计算原理。</p><p>这里的难点是当链表长度不同的情况，需要如何处理，这里采取的方法是用0来补位，即长度短的链表后续用0来进行计算，避免了大量的判断结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *head = <span class="literal">nullptr</span>, *tail = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="type">int</span> n1 = l1 ? l1-&gt;val: <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> n2 = l2 ? l2-&gt;val: <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> sum = n1 + n2 + carry;</span><br><span class="line">            <span class="keyword">if</span> (!head) &#123;</span><br><span class="line">                head = tail = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">                tail = tail-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (l1) &#123;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l2) &#123;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            tail-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里利用了三亩运算符来进行相关0的补充，carry代表相关的进位，利用head作为返回指针，tail来进行遍历。<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528164458.png"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2023/05/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2023/05/28/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528102555.png"></p><p>在这个题目中，主要思想就是找数。<br>主要分为两个思路：</p><ol><li><p>暴力搜寻</p><p>简单来说就是for嵌套</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==target-nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上述代码中，注意一个细节，在if的判断条件中，这里并没有采用加法条件，主要原因是如果采用加法就很可能出现溢出的情况，所以采用减法的方式，这样就可以避免这种问题。具体执行时间大概在：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528111032.png"></p><ol start="2"><li><p>哈希表查询</p><p> 哈希表是一种查找结构，可以实现key和value的一一对应，具体哈希表内部采用的算法，可看<a href="https://blog.csdn.net/Peealy/article/details/116895964">https://blog.csdn.net/Peealy/article/details/116895964</a></p><p> 在代码中主要是采用unordered_map和unordered_set来进行相关操作，其具体操作在代码中的体现可见<a href="https://blog.csdn.net/m0_52318340/article/details/126050490">https://blog.csdn.net/m0_52318340/article/details/126050490</a></p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;<span class="built_in">int</span>&gt; twoSum(vector&lt;<span class="built_in">int</span>&gt;&amp; nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        unordered_map&lt;<span class="built_in">int</span>, <span class="built_in">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            auto it = hashtable.find(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hashtable.end()) &#123;//在哈希表中找值</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在代码中，逻辑主要是遍历数组，利用哈希表查找是否有target-nums[i]的key，如果有，则返回对应value和序号组成的数组，否则，进行hash表插值，key为数组元素的值，value为数组元素的序号。<br>整体运行消耗：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528121440.png"></p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在VScode中预览书写的markdown文件</title>
      <link href="/2023/05/28/%E5%9C%A8VScode%E4%B8%AD%E9%A2%84%E8%A7%88%E4%B9%A6%E5%86%99%E7%9A%84markdown%E6%96%87%E4%BB%B6/"/>
      <url>/2023/05/28/%E5%9C%A8VScode%E4%B8%AD%E9%A2%84%E8%A7%88%E4%B9%A6%E5%86%99%E7%9A%84markdown%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>在VScode中，可以实现对markdown文件中的编写，首先是进行相关插件的安装，具体参考链接<br><a href="https://zhuanlan.zhihu.com/p/56943330">https://zhuanlan.zhihu.com/p/56943330</a></p><p>在具体的实现VScode中，在编写相关markdown文件时，首先ctrl+K,在按v，即可实现相关预览功能。<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230528103659.png"></p>]]></content>
      
      
      <categories>
          
          <category> 使用技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于多特征提取的换脸视频检测</title>
      <link href="/2023/05/27/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%9A%84%E6%8D%A2%E8%84%B8%E8%A7%86%E9%A2%91%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/05/27/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96%E7%9A%84%E6%8D%A2%E8%84%B8%E8%A7%86%E9%A2%91%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在毕业课设中，我选择的是相对应用性较强的课题–换脸检测。这次课题主要使用的技术为深度学习，在课设中使用的主要是CNN+LSTM的结构。</p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>由于深度学习模型训练的需要，对于电脑的CPU要求较高(我的电脑没有英伟达GPU)，所以在学校申请了一个内存为16G，硬盘为150G，系统为ubuntu20.04的远程主机进行相关工作。</p><h1 id="具体工作介绍"><a href="#具体工作介绍" class="headerlink" title="具体工作介绍"></a>具体工作介绍</h1><p>本人能力微薄，整体的深度学习代码并不能完全由自己写出，所以主要功能代码是借鉴github上的开源项目<br><a href="https://github.com/abhijitjadhav1998/Deepfake_detection_using_deep_learning">https://github.com/abhijitjadhav1998/Deepfake_detection_using_deep_learning</a></p><p>虽然主要功能代码是参照这个来的，但有几点需要注意一下。</p><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>在课题中，为了实现对人脸部分的检测分析，需要进行相关数据预处理操作，在这个过程中，需要进行<strong>人脸识别</strong>，这里我采用了开源的MTCNN模型，这个模型主要由P-NET,R-NET,以及O-NET组成，需要依次对这三个模型进行训练。</p><p>在换脸模型训练中，主要采用的数据集为Celeb-DF v1版本的数据集，其主要包含1203个视频，在实际工作中我采用的·方法是在开源代码中进行相关修改，使得其功能变为将指定文件夹中的视频文件对其前60帧进行相关人脸识别工作，提取其人脸盒子，裁剪图片，合成人脸视频保存在指定文件夹中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vdprocess</span>(<span class="params">videos_src_path,videos_save_path</span>):</span><br><span class="line"> </span><br><span class="line">    <span class="comment"># 获取指定路径下的文件</span></span><br><span class="line">    dirs = os.listdir(videos_src_path)</span><br><span class="line">    <span class="keyword">for</span> video_dir <span class="keyword">in</span> dirs:</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        video_path = os.path.join(videos_src_path,video_dir)</span><br><span class="line">        videoCapture = cv2.VideoCapture(video_path)</span><br><span class="line">        videoname = video_path.split(<span class="string">&#x27;/&#x27;</span>)[-<span class="number">1</span>]</span><br><span class="line">        video_save_path = os.path.join(videos_save_path,videoname)</span><br><span class="line">        <span class="keyword">if</span>(videoCapture.isOpened()):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Open&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;Fail to open&#x27;</span>)</span><br><span class="line">        fps = videoCapture.get(cv2.CAP_PROP_FPS)</span><br><span class="line">        out = cv2.VideoWriter(video_save_path,cv2.VideoWriter_fourcc(<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;V&#x27;</span>),fps,(<span class="number">224</span>,<span class="number">224</span>))</span><br><span class="line">        frame=<span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            success,frame = videoCapture.read()</span><br><span class="line">        boxes_c, landmarks = infer_image(frame)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;start&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> success:</span><br><span class="line">            <span class="keyword">if</span> boxes_c <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">if</span> count != <span class="number">5</span>  :</span><br><span class="line">                    count = count + <span class="number">1</span></span><br><span class="line">                    <span class="built_in">print</span>(count)</span><br><span class="line">                    <span class="keyword">if</span>(count == <span class="number">1</span>):</span><br><span class="line">                        <span class="built_in">print</span>(frame.shape[<span class="number">0</span>])</span><br><span class="line">                        <span class="built_in">print</span>(frame.shape[<span class="number">1</span>])</span><br><span class="line">                        <span class="built_in">print</span>(boxes_c)</span><br><span class="line">                        top = <span class="built_in">int</span>(boxes_c[<span class="number">0</span>][<span class="number">1</span>])</span><br><span class="line">                        <span class="built_in">print</span>(top)</span><br><span class="line">                        bottom = <span class="built_in">int</span>(boxes_c[<span class="number">0</span>][<span class="number">3</span>])</span><br><span class="line">                        <span class="built_in">print</span>(bottom)</span><br><span class="line">                        left = <span class="built_in">int</span>(boxes_c[<span class="number">0</span>][<span class="number">0</span>])</span><br><span class="line">                        <span class="built_in">print</span>(left)</span><br><span class="line">                        right = <span class="built_in">int</span>(boxes_c[<span class="number">0</span>][<span class="number">2</span>])</span><br><span class="line">                        <span class="built_in">print</span>(right)</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">try</span>:</span><br><span class="line">                        out.write(cv2.resize(frame[top:bottom,left:right],(<span class="number">224</span>,<span class="number">224</span>)))</span><br><span class="line">                        <span class="comment"># cv2.imshow(&#x27;result&#x27;, frame[top:bottom,left:right])</span></span><br><span class="line">                        <span class="comment"># cv2.waitKey(100)</span></span><br><span class="line">                        </span><br><span class="line">                        </span><br><span class="line">                    <span class="keyword">except</span>:</span><br><span class="line">                        <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)</span><br><span class="line">                        count = count - <span class="number">1</span></span><br><span class="line">                        frame = <span class="literal">None</span></span><br><span class="line">                        <span class="keyword">while</span> frame <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> success:</span><br><span class="line">                            success,frame = videoCapture.read()</span><br><span class="line">                        <span class="keyword">if</span> success:</span><br><span class="line">                            boxes_c, landmarks = infer_image(frame)</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                frame = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">while</span> frame <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> success:</span><br><span class="line">                    success,frame = videoCapture.read()</span><br><span class="line">                <span class="keyword">if</span> success:</span><br><span class="line">                    boxes_c, landmarks = infer_image(frame)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> count == <span class="number">5</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">            frame = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">while</span> frame <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">and</span> success:</span><br><span class="line">                success,frame = videoCapture.read()</span><br><span class="line">            <span class="keyword">if</span> success:</span><br><span class="line">                boxes_c, landmarks = infer_image(frame)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;finish one step&#x27;</span>)</span><br><span class="line">        videoCapture.release()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的输入参数分别为videos_src_path,videos_save_path，两者分别代表存放视频文件夹的文件夹和存放人脸视频文件夹的文件夹，注意这里的表述，这里的核心函数是infer_image,它会识别输入图片的的人脸位置以及人脸特征点，这里主要使用其返回的人脸位置。</p><p>在实际使用过程中，利用opencv提供的函数进行相关人脸帧的提取，以及人脸视频的合成。由于并不是读取到的每一帧都可以进行人脸提取，所以需要使用try等代码块进行逻辑判断，这里的判断结构我写得很拥挤，应该可以进行改善。</p><p>整体代码为了缩短运行时间，采用的方法是每5帧识别一次人脸，然后利用相关的人脸盒子对分组的5帧进行裁剪。</p><p>整体的效果可以看一下，下图是原始的视频数据集：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230527211045.png"></p><p>下图是处理过后的数据集：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230527211259.png"></p><h2 id="换脸模型训练"><a href="#换脸模型训练" class="headerlink" title="换脸模型训练"></a>换脸模型训练</h2><p>在换脸模型训练中，数据输入之后会进行进一步处理，这里的主要处理过程在代码中的表现如下：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/20230527211554.png"></p><p>这里的具体理解过程可以查一下百度，之后如果再学习到该领域，更新一下内容。</p><p>然后是整体的模型定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Model</span>(nn.Module):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, num_classes,latent_dim= <span class="number">2048</span>, lstm_layers=<span class="number">1</span> , hidden_dim = <span class="number">2048</span>, bidirectional = <span class="literal">False</span></span>):</span><br><span class="line">        <span class="built_in">super</span>(Model, self).__init__()</span><br><span class="line">        model = models.resnext50_32x4d(pretrained = <span class="literal">True</span>) <span class="comment">#Residual Network CNN</span></span><br><span class="line">        self.model = nn.Sequential(*<span class="built_in">list</span>(model.children())[:-<span class="number">2</span>])</span><br><span class="line">        self.lstm = nn.LSTM(latent_dim,hidden_dim, lstm_layers,  bidirectional)</span><br><span class="line">        self.relu = nn.LeakyReLU()</span><br><span class="line">        self.dp = nn.Dropout(<span class="number">0.4</span>)</span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">2048</span>,num_classes)</span><br><span class="line">        self.avgpool = nn.AdaptiveAvgPool2d(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        batch_size,seq_length, c, h, w = x.shape</span><br><span class="line">        x = x.view(batch_size * seq_length, c, h, w)</span><br><span class="line">        fmap = self.model(x)</span><br><span class="line">        x = self.avgpool(fmap)</span><br><span class="line">        x = x.view(batch_size,seq_length,<span class="number">2048</span>)</span><br><span class="line">        x_lstm,_ = self.lstm(x,<span class="literal">None</span>)</span><br><span class="line">        <span class="keyword">return</span> fmap,self.dp(self.linear1(torch.mean(x_lstm,dim = <span class="number">1</span>)))</span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">model = Model(<span class="number">2</span>).to(device)</span><br></pre></td></tr></table></figure><p>在该模型中，其主体架构势CNN+LSTM，采用的CNN架构为resnext50_32 $\times$ 4d<br>,具体结构图为：<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/resnet%E5%92%8Cresnext%E7%BB%93%E6%9E%84%E5%9B%BE.jpg"></p><p>在代码中，并没有使用上述模型的全部层，而是在conv5时便停止，这里是为了和后方LSTM的输入项匹配。<br>在相关LSTM的代码中，其输入为2048维的向量，采用的LSTM层为一层，具体nn.lstm函数的参数含义请自行查证。整体的训练过程使用已经定义的函数即可，注意参考代码中需要注意一段代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#a,b = model(torch.from_numpy(np.empty((1,20,3,112,112))).type(torch.FloatTensor))</span></span><br></pre></td></tr></table></figure><p>在修改完输入的视频数据路径后，进行训练过程可以得到最终的准确率大概在90%左右。<br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/train.jpg"><br><img src="https://raw.githubusercontent.com/gateofsteins/blogImage/main/%E8%AE%AD%E7%BB%83%E7%BB%93%E6%9E%9C.jpg"></p><p>这里是最为基础的工作，由于这里分析视频的时空特征，难以进行建模，所以针对于多特征，我还分析了相关换脸图片的RGB,ELA,SURF等特征。这里不加详述，因为在视频检测领域，图像检测方法一般是不太实用的。</p><p>下面是我在这几个月来一些有用的参考链接，可以借鉴一下：</p><ol><li><a href="https://zhuanlan.zhihu.com/p/412454281">Deepfake数据集</a></li><li><a href="https://www.jianshu.com/p/43f66c69baa7">Ubuntu18.04安装cpu版pytorch环境</a></li><li><a href="https://blog.csdn.net/qq_35713680/article/details/108436466">VScode使用SSH连接Linux（Ubuntu）系统程序开发，详细教程</a></li><li><a href="https://github.com/yeyupiaoling/Pytorch-MTCNN">基于Pytorch实现的MTCNN模型，人脸检测，人脸关键点检测</a></li><li><a href="https://blog.csdn.net/Jia_Feng_/article/details/116670461">No module named ‘cv2‘ 解决办法</a></li><li><a href="https://blog.csdn.net/Amorny959/article/details/125504289?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167750639216800182742815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167750639216800182742815&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-2-125504289-null-null.142%5Ev73%5Einsert_down4,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&utm_term=no%20module%20named%20tqdm&spm=1018.2226.3001.4187">python：No module named ‘tqdm’</a></li><li><a href="https://github.com/yuezunli/celeb-deepfakeforensics">Celeb-DF: A Large-scale Challenging Dataset for DeepFake Forensics</a></li><li><a href="https://blog.csdn.net/Mercury_Lc/article/details/103549325">linux 查看剩余空间命令</a></li><li><a href="https://github.com/Allenem/graduation-design/tree/master/Spectrum_SVM4Image_and_Resnet_LSTM4Video">相同毕设借鉴</a></li><li><a href="https://github.com/abhijitjadhav1998/Deepfake_detection_using_deep_learning/blob/master/Model%20Creation/Readme.md">借鉴的始祖</a></li><li><a href="https://blog.csdn.net/GeorgeAI/article/details/81035422">glob.glob() 函数</a></li><li><a href="https://zhuanlan.zhihu.com/p/245073121">OpenCV 之VideoCapture</a></li><li><a href="https://blog.csdn.net/u011119817/article/details/108519389">Colab基本使用方法及配置(我没有用但的确有用)</a></li><li><a href="https://blog.csdn.net/qq_34020487/article/details/101871752">Python中face_recognition库的安装</a></li><li><a href="https://www.jianshu.com/p/949683764115">python中VideoCapture()，read()，waitKey()的使用</a></li><li><a href="https://blog.csdn.net/weixin_40671425/article/details/109035231">解决：OpenCV: FFMPEG: tag 0x5634504d&#x2F;‘MP4V‘ is not supported with codec id 12 and format ‘mp4 &#x2F; MP4 (MP</a></li><li><a href="https://zhuanlan.zhihu.com/p/424518359">如何理解归一化（normalization）?</a></li><li><a href="https://zhuanlan.zhihu.com/p/476220305">transforms.Compose()使用</a></li><li><a href="https://www.w3schools.cn/python/ref_random_shuffle.asp">Python Random shuffle() 方法</a></li><li><a href="https://blog.csdn.net/jia2799897415/article/details/116204929">input上传视频并本地预览</a></li><li><a href="https://www.cnblogs.com/kkhan/p/17155737.html">Pycharm专业版破解到永久方案</a></li><li><a href="https://blog.csdn.net/xuru_0927/article/details/119274321">model.load_state_dict(state_dict)报错问题</a></li><li><a href="https://zhuanlan.zhihu.com/p/200783234">利用OpenCV进行H264视频编码的简易方式</a></li><li><a href="https://blog.csdn.net/wwyy2018/article/details/100081457">深度学习中的 logits 、softmax，TensorFlow中的 tf.nn.softmax_cross_entropy_with_logits 、tf.nn.sparse_soft…对比</a></li><li><a href="https://blog.csdn.net/zhao2chen3/article/details/117933622">Python time clock()方法</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 毕业课设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/05/26/hello-world/"/>
      <url>/2023/05/26/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
